/*
   Copyright The containerd Authors.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

type Aliasen struct {
	SrcPath    string
	SrcName    string
	DstName    string
	DstFile    string
	Out        *os.File
	BuildFlags []string
	License    string
	Filtered   []string
	Constants  []string
	Variables  []string
	Types      []string
	Functions  []string
	Command    []string
}

func (a *Aliasen) Collect(src, dst *packages.Package) {
	if src == nil {
		return
	}

	names := src.Types.Scope().Names()
	if len(names) == 0 {
		return
	}

	conflicts := []string{}

	for _, name := range names {
		obj := src.Types.Scope().Lookup(name)
		if obj == nil || !obj.Exported() {
			continue
		}

		if o := dst.Types.Scope().Lookup(name); o != nil {
			if a.Filtered != nil {
				fmt.Fprintf(os.Stderr,
					"skipping %s: filtering existing/conflicting name...\n", name)
				a.Filtered = append(a.Filtered, name)
				continue
			}
			conflicts = append(conflicts, name)
		}

		switch obj.(type) {
		case *types.Const:
			a.Constants = append(a.Constants, name)
		case *types.Var:
			a.Variables = append(a.Variables, name)
		case *types.TypeName:
			a.Types = append(a.Types, name)
		case *types.Func:
			a.Functions = append(a.Functions, name)
		}
	}

	if len(conflicts) > 0 {
		for _, name := range conflicts {
			fmt.Fprintf(os.Stderr, "error: conflicting name %s already defined\n", name)
		}
		os.Exit(1)
	}
}

func (a *Aliasen) Emit() {
	if len(a.Types)+len(a.Functions)+len(a.Constants)+len(a.Variables) == 0 {
		return
	}

	if a.Out == nil {
		f, err := os.OpenFile(a.DstFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o0644)
		if err != nil {
			log.Fatalf("failed to open file %s: %v", a.DstFile, err)
		}
		a.Out = f
		defer f.Close()
	}

	a.EmitHeader()
	a.EmitBlock(a.Constants, "aliased constants", "const")
	a.EmitBlock(a.Variables, "aliased variables", "var")
	a.EmitBlock(a.Types, "aliased types", "type")
	a.EmitBlock(a.Functions, "aliased functions", "var")
	a.EmitBlock(a.Filtered, "filtered conflicting names", "// filtered due to conflicts")
}

func (a *Aliasen) EmitHeader() {
	if len(a.BuildFlags) > 0 {
		for _, f := range a.BuildFlags {
			a.emit("//go:build %s\n", f)
		}
		a.emit("\n")
	}

	if a.License != "" {
		a.emit("%s\n", a.License)
	}
	a.emit("// Code generated by %s. DO NOT EDIT.\n", filepath.Base(a.Command[0]))
	a.emit("\n")
	a.emit("//nolint:revive\n")
	a.emit("package %s\n", a.DstName)
	a.emit("\n")
	a.emit("import (\n")
	a.emit("    \"%s\"\n", a.SrcPath)
	a.emit(")\n")
}

func (a *Aliasen) EmitBlock(names []string, kind, keyword string) {
	if len(names) == 0 {
		return
	}

	a.emit("\n")

	comment := ""
	if strings.HasPrefix(keyword, "//") {
		comment = "// "
	}
	max := maxLen(names)
	a.emit("// %s from %s\n", kind, a.SrcPath)
	a.emit("%s (\n", keyword)
	for _, n := range names {
		a.emit("%s    %-*s = %s.%s\n", comment, max, n, a.SrcName, n)
	}
	a.emit("%s)\n", comment)
}

func (a *Aliasen) emit(format string, args ...interface{}) {
	if _, err := fmt.Fprintf(a.Out, format, args...); err != nil {
		log.Fatalf("failed to write %s: %v\n", a.DstFile, err)
	}
}

func maxLen(strings []string) int {
	max := 0
	for _, s := range strings {
		if len(s) > max {
			max = len(s)
		}
	}
	return max
}

func main() {
	var (
		srcDir  = flag.String("src", "", "source package path")
		dstDir  = flag.String("dst", "", "destination package path")
		output  = flag.String("out", "", "output file name")
		bFlags  = flag.String("build-flags", "", "build flags to pass to go/packages")
		licFile = flag.String("license", "", "file to read license header from")
		remove  = flag.Bool("remove", false, "remove output before loading destination package")
		filter  = flag.Bool("filter-conflicting", false, "filter conflicting names")
		license = ""
	)

	flag.StringVar(srcDir, "s", "", "source package path")
	flag.StringVar(dstDir, "d", "", "destination package path")
	flag.StringVar(output, "o", "", "output file name")
	flag.StringVar(bFlags, "b", "", "build flags to pass to go/packages")
	flag.StringVar(licFile, "l", "", "file to read license header from")
	flag.BoolVar(remove, "rm", false, "remove output before loading destination package")
	flag.BoolVar(filter, "f", false, "filter conflicting names")

	if err := flag.CommandLine.Parse(os.Args[1:]); err != nil {
		log.Fatalf("invalid command line: %v\n", err)
	}

	if *srcDir == "" {
		fmt.Fprintf(os.Stderr, "missing source package\n")
		flag.CommandLine.Usage()
		os.Exit(1)
	}
	if *dstDir == "" {
		fmt.Fprintf(os.Stderr, "missing destination package\n")
		flag.CommandLine.Usage()
		os.Exit(1)
	}

	if *output == "" {
		*output = "-"
	}
	if *output != "-" {
		if filepath.Base(*output) != *output {
			log.Fatalf("output file name has directory prefix\n")
		}
		if filepath.Ext(*output) != ".go" {
			*output += ".go"
		}

		if *remove {
			if err := os.Remove(filepath.Join(*dstDir, *output)); err != nil {
				if !os.IsNotExist(err) {
					log.Fatalf("failed to remove output file %s: %v\n", *output, err)
				}
			}
		}
	}

	if *licFile != "" {
		l, err := os.ReadFile(*licFile)
		if err != nil {
			log.Fatalf("failed to read license header file %s: %v\n", *licFile, err)
		}
		license = string(l)
	}

	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedImports |
			packages.NeedDeps,
		Tests: false,
	}

	src, err := packages.Load(cfg, *srcDir)
	if err != nil {
		log.Fatalf("failed to load source package %s: %v", *srcDir, err)
	}
	if packages.PrintErrors(src) > 0 {
		os.Exit(1)
	}
	if len(src) != 1 {
		fmt.Fprintf(os.Stderr, "expecting 1 source package, got %d\n", len(src))
	}

	dst, err := packages.Load(cfg, *dstDir)
	if err != nil {
		log.Fatalf("failed to load destination package %s: %v", *dstDir, err)
	}
	if packages.PrintErrors(dst) > 0 {
		fmt.Fprintf(os.Stderr, "printed dst errors...\n")
		os.Exit(1)
	}
	if len(dst) != 1 {
		fmt.Fprintf(os.Stderr, "expecting 1 destination package, got %d\n", len(dst))
	}

	a := &Aliasen{
		DstName: dst[0].Name,
		DstFile: *output,
		License: license,
		Command: os.Args,
	}

	if *filter {
		a.Filtered = []string{}
	}

	if *bFlags != "" {
		a.BuildFlags = strings.Split(*bFlags, ",")
	}

	if *output == "-" {
		a.Out = os.Stdout
	} else {
		a.DstFile = filepath.Join(*dstDir, *output)
	}

	a.SrcPath = src[0].PkgPath
	a.SrcName = src[0].Name

	a.Collect(src[0], dst[0])
	a.Emit()
}
